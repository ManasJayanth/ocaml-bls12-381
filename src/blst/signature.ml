module Stubs = Blst_bindings.StubsSignature (Blst_stubs)
module StubsFr = Blst_bindings.StubsFr (Blst_stubs)
module StubsG1 = Blst_bindings.StubsG1 (Blst_stubs)
module StubsG2 = Blst_bindings.StubsG2 (Blst_stubs)

type sk = Blst_bindings.Types.blst_scalar_t Ctypes.ptr

type pk = Blst_bindings.Types.blst_g1_t Ctypes.ptr

let sk_of_bytes_exn bytes =
  let buffer = Blst_bindings.Types.allocate_scalar () in
  if Bytes.length bytes > 32 then
    raise
      (Invalid_argument
         "Input should be maximum 32 bytes, encoded the secret key in little \
          endian")
  else
    let sk = Fr.of_bytes_exn bytes in
    StubsFr.scalar_of_fr buffer sk ;
    buffer

(* let sk_of_bytes_opt bytes =
 *   let buffer = Blst_bindings.Types.allocate_scalar () in
 *   if Bytes.length bytes > 32 then None
 *   else (
 *     StubsFr.scalar_of_bytes_le buffer (Ctypes.ocaml_bytes_start bytes) ;
 *     Some buffer ) *)

let sk_to_bytes sk =
  let bytes = Bytes.make 32 '\000' in
  StubsFr.scalar_to_bytes_le (Ctypes.ocaml_bytes_start bytes) sk ;
  bytes

let generate_sk ?(key_info = Bytes.empty) ikm =
  let buffer_scalar = Blst_bindings.Types.allocate_scalar () in
  let key_info_length = Bytes.length key_info in
  let ikm_length = Bytes.length ikm in

  (*
    https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04
    Section 2.3 - KeyGen

    For security, IKM MUST be infeasible to guess, e.g., generated by a
    trusted source of randomness.  IKM MUST be at least 32 bytes long,
    but it MAY be longer.

    Also, blst_keygen returns a vector of zero (commit
    095a8c53787d6c91b725152ebfbbf33acf05a931) if ikm is less than 32 bytes
  *)
  assert (ikm_length >= 32) ;
  Stubs.keygen
    buffer_scalar
    (Ctypes.ocaml_bytes_start ikm)
    (Unsigned.Size_t.of_int ikm_length)
    (Ctypes.ocaml_bytes_start key_info)
    (Unsigned.Size_t.of_int key_info_length) ;
  buffer_scalar

let derive_pk sk =
  let buffer_g1 = Blst_bindings.Types.allocate_g1 () in
  Stubs.sk_to_pk buffer_g1 sk ;
  buffer_g1

let pk_of_bytes pk_bytes = G1.of_bytes_opt pk_bytes

module Basic = struct
  let dst = Bytes.of_string "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_"

  let dst_length = Bytes.length dst

  let sign sk message =
    let hash = G2.hash_to_curve message dst in
    let buffer = Blst_bindings.Types.allocate_g2 () in
    Stubs.sign buffer hash sk ;
    G2.to_bytes buffer

  let verify pk msg signature =
    let msg_length = Bytes.length msg in
    let signature_opt = G2.of_bytes_opt signature in
    match signature_opt with
    | None -> false
    | Some signature ->
        let signature_affine = Blst_bindings.Types.allocate_g2_affine () in
        StubsG2.to_affine signature_affine signature ;
        let pk_affine = Blst_bindings.Types.allocate_g1_affine () in
        StubsG1.to_affine pk_affine pk ;
        let res =
          Stubs.core_verify
            pk_affine
            signature_affine
            (* to use hash_to_curve *)
            true
            (Ctypes.ocaml_bytes_start msg)
            (Unsigned.Size_t.of_int msg_length)
            (Ctypes.ocaml_bytes_start dst)
            (Unsigned.Size_t.of_int dst_length)
            (Ctypes.ocaml_bytes_start Bytes.empty)
            Unsigned.Size_t.zero
        in
        res = 0

  (* let aggregate_signature sks_with_msgs =
   *   let rec aux sks_with_msgs ctxt =
   *     match sks_with_msgs with
   *     | (sk, msg) :: rest ->
   *         (\* sign the message *\)
   *         let hash = G2.hash_to_curve msg dst in
   *         let signature = Blst_bindings.Types.allocate_g2 () in
   *         Stubs.sign signature hash sk ;
   *         let pk = derive_pk sk in
   *         let msg_length = Bytes.length msg in
   *         let res =
   *           Stubs.aggregate_signature
   *             ctxt
   *             pk
   *             signature
   *             (Ctypes.ocaml_bytes_start msg)
   *             msg_length
   *             (Ctypes.ocaml_bytes_start Bytes.empty)
   *             Unsigned.Size_t.zero
   *         in
   *         assert (res = 0) ;
   *         aux rest ctxt
   *     | [] -> ctxt
   *   in
   *   let ctxt = Blst_bindings.Types.allocate_aggregation_ctxt () in
   *   aux sks_with_msgs ctxt *)
end

module Aug = struct
  let sign sk msg =
    let dst = Bytes.of_string "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_AUG_" in
    let pk = derive_pk sk in
    let pk_bytes = G1.to_bytes pk in
    let msg = Bytes.concat Bytes.empty [pk_bytes; msg] in
    let hash = G2.hash_to_curve msg dst in
    let buffer = Blst_bindings.Types.allocate_g2 () in
    Stubs.sign buffer hash sk ;
    G2.to_bytes buffer

  let verify pk msg signature =
    let pk_bytes = G1.to_bytes pk in
    let msg = Bytes.concat Bytes.empty [pk_bytes; msg] in
    let msg_length = Bytes.length msg in
    let dst = Bytes.of_string "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_AUG_" in
    let dst_length = Bytes.length dst in
    let signature_opt = G2.of_bytes_opt signature in
    match signature_opt with
    | None -> false
    | Some signature ->
        let signature_affine = Blst_bindings.Types.allocate_g2_affine () in
        StubsG2.to_affine signature_affine signature ;
        let pk_affine = Blst_bindings.Types.allocate_g1_affine () in
        StubsG1.to_affine pk_affine pk ;
        let res =
          Stubs.core_verify
            pk_affine
            signature_affine
            (* to use hash_to_curve *)
            true
            (Ctypes.ocaml_bytes_start msg)
            (Unsigned.Size_t.of_int msg_length)
            (Ctypes.ocaml_bytes_start dst)
            (Unsigned.Size_t.of_int dst_length)
            (Ctypes.ocaml_bytes_start Bytes.empty)
            Unsigned.Size_t.zero
        in
        res = 0
end
